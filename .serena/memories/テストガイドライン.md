# テストガイドライン

テストは品質保証の基盤であり、すべての新機能に対して必須である。


## テストサイズの定義（Google Testing Blog 準拠）

テストは実行時間と外部依存によって以下の3つのサイズに分類される：

### Small テスト: `*.small.[server|browser].test.{ts,tsx}`
- 単一プロセス内で完結するテスト
- 外部依存（ネットワーク、データベース、ファイルシステム等）を使用しない
- 高速に実行される（通常 < 100ms）
- 例: 純粋関数、ユーティリティ、ビジネスロジックのユニットテスト

### Medium テスト: `*.medium.[server|browser].test.{ts,tsx}`
- 単一マシン内で完結するテスト
- ローカルの外部依存（データベース、ファイルシステム等）を使用可能
- ネットワークを介した外部サービスへのアクセスは不可
- 例: データベース統合テスト、ファイル I/O を含むテスト

### Large テスト (E2E): `*.e2e.test.{ts,tsx}`
- 複数プロセス・マシンにまたがるテスト
- すべての外部依存を使用可能
- 実際のユーザーフローをエンドツーエンドで検証
- 例: ブラウザ自動化テスト、API 統合テスト
- 本プロジェクトでは Large テストは原則的に playwright の e2e テストとして実装する



## テスト哲学

### 振る舞いをテストする
ユーザーから見た振る舞い（外部から観察可能な動作）をテストすること。

- ❌ 悪い例: 「maxlength属性が設定されている」「特定のテキストが表示される」
- ✅ 良い例: 「最大文字数を超えて入力できない」「エラー時に送信できない」
- 実装方法（どの属性を使うか、どの関数を呼ぶか）ではなく、結果（何が起こるか）をテストする

### 公開インターフェースのテスト
公開された API、関数、コンポーネントの動作をテストすること。

### 内部実装のテストを避ける
内部のプライベートメソッドや実装詳細に依存したテストは避けること。
- 実装の変更に対してテストが壊れることを防ぐ
- リファクタリングの自由度を保つ
- テストは「何をするか」に焦点を当て、「どうやるか」には焦点を当てない

## 統合テストの優先

- **結合された状態でのテスト**: 極力、実際の依存関係を使用した統合テストを優先すること
- **過剰な Mock の使用を避ける**: Mock は最小限にとどめ、必要な場合のみ使用すること
  - Mock を使うと実際の統合問題を見逃す可能性がある
  - Mock の保守コストが高くなる
  - テストが実装詳細に依存しやすくなる

## Mock 使用の原則

### Mock が許容される場合
外部 API やサードパーティサービスなど、制御できない外部依存のみ。
- 例: 決済サービス、メール送信サービス、外部データプロバイダー
- これらは信頼性、コスト、テスト実行速度の観点から Mock が適切

### Mock を避けるべき場合
プロジェクト内部の依存関係、データベース、ファイルシステム。
- これらは実際の実装を使用してテストすること

### 内部実装とモックの扱い
- **基本原則**: 内部実装の詳細（どの関数が呼ばれたか）はテストしない
  - テストは「何をするか」に焦点を当て、「どうやるか」には焦点を当てない
  - 公開された振る舞い（UIの変化、ユーザーに見える結果）をテストする
- **例外: 外部への副作用のテスト**
  - セキュリティやパフォーマンスの観点から、特定の操作で外部への副作用がないことを確認する必要がある場合は例外的に許容
  - 例: バリデーションエラー時にサーバーリクエストが発生しない、権限不足時に認証APIが呼ばれない

## データベーステスト

- **Mock データベースを避ける**: Mock や Fake のデータベース実装は使用しないこと
- **実際のデータベースを使用**: テストには以下のいずれかを使用すること
  - Docker コンテナで起動した実際のデータベース（PostgreSQL, MySQL など）
  - In-memory データベース（SQLite in-memory mode など）
  - トランザクションロールバックを使用したテスト分離
- これにより、SQL クエリ、制約、トリガーなどの実際の動作を検証できる

## テストカバレッジとタイプ

- 新機能・変更には必ずテストを作成すること
- テストカバレッジ目標は 80%以上を維持すること
- E2E テストで主要なユーザーフローを検証すること
- テストファースト開発を推奨し、Red-Green-Refactor サイクルを意識すること
- テストは読みやすく、保守しやすく、意図が明確であること
- エッジケース・エラーハンドリングもテストでカバーすること

## テスト構造の共通原則

### fixture 機能を優先
テストのセットアップ・ティアダウンなど共通処理は fixture 機能を使用すること。

`beforeEach`/`afterEach` よりも fixture を優先する理由:
- テストごとに必要な依存関係のみを明示的に宣言できる
- 自動的にクリーンアップが行われる
- テストの独立性が高まり、テストの順序に依存しない

Playwright と Vitest の両方で `test.extend()` を使用してカスタム fixture を定義。

**Vitest Browser Mode での実装例:**
```typescript
import { test as base } from "vitest";

const test = base.extend<{ loginActionMock: Mock }>({
  loginActionMock: async ({}, use) => {
    const loginActionModule = await import("./login-action");
    const mock = vi.mocked(loginActionModule.loginAction);
    await use(mock);
    vi.clearAllMocks();  // 自動クリーンアップ
  },
});

test("ログインテスト", async ({ loginActionMock }) => {
  // loginActionMock が自動的に提供され、テスト後に自動クリーンアップされる
});
```

### フラットな構造を優先
`test.describe()` は単純なグルーピングのためには使用しない。
- `describe` はグループごとに共通処理（beforeEach, afterEach など）を実施したい場合にのみ使用すること
- 基本的にはフラットな構造でテストを作成すること

## テストのクエリ優先度

テストでは以下の優先順位でクエリを使用すること。上位のクエリほどアクセシビリティを保証し、実装の詳細に依存しない。

1. **アクセシブルクエリ（最優先）**
   - すべてのユーザー（視覚/マウス利用者、支援技術利用者）の体験を反映
   - 例: `getByRole()`, `getByLabelText()`, `getByPlaceholderText()`, `getByText()`

2. **セマンティッククエリ**
   - HTML5 と ARIA に準拠したセレクター（ブラウザや支援技術で体験が異なる場合がある）
   - 例: `getByAltText()`, `getByTitle()`

3. **テスト ID（最終手段）**
   - 他の方法で特定できない場合のみ使用
   - 例: `getByTestId()`

## ブラウザテストと E2E テストの使い分け

### ブラウザテスト（Vitest Browser Mode）
同期的でブラウザ内で完結する振る舞いをテストする。
- クライアントサイドバリデーション（必須項目、フォーマット検証など）
- ユニバーサルコンポーネントやクライアントコンポーネントの表示・操作
- ローディング状態やエラー表示などのUI状態
- Server Actionやバックエンドとの統合は含まない（モックを使用）

### E2E テスト（Playwright）
サーバー、クライアント、データベースが統合して動作する振る舞いをテストする。
- ユーザー登録からログイン、データ作成までのフロー全体
- Server Actionを経由したデータベース操作
- 認証・認可を含む実際のユーザーフロー
- 外部APIとの統合やリダイレクトなど

## コンポーネントテスト（Vitest Browser Mode）の原則

### page オブジェクトの使用
`screen` ではなく `page` を常に使用すること。
- クエリ: `page.getByRole()`, `page.getByLabelText()` など
- アサーション: `await expect.element(page.getByRole(...)).toBeInTheDocument()` を使用
- 理由: Vitest Browser Mode では `page` が標準のブラウザAPIを提供する
- `screen` は Testing Library の概念であり、Vitest Browser Mode では使用しない

## E2E テスト固有の原則

### テストの統合
E2E テストは実行コストが高いため、フローが同一の場合は別観点のテストケースであっても統合して実施すること。
- 例: 「ログイン成功」と「ブラウザバック後の挙動」は同一フロー内で検証

### test.step の使用
操作単位で `test.step()` を使用し、テストレポートで操作内容を明確にすること。
- 各ステップは簡潔で意味のある名前を付ける
- ステップ内では関連する操作をまとめる
- テスト失敗時にどのステップで失敗したかが一目でわかるようにする
