# コードスタイル

## 開発原則

- You Aren't Gonna Need It (YAGNI)
- Single Responsibility Principle (SRP)
- Keep it Simple, Stupid (KISS)
- Avoid Hasty Abstractions (AHA)
- Don't repeat yourself (DRY)
- **シンプルさの優先**: 汎用性や厳密性よりも常にシンプルな選択を採用すること
  - 将来の拡張性を過度に考慮せず、現在必要な機能に絞ること
  - 複雑な型定義や厳密なバリデーションよりも、読みやすく理解しやすいコードを優先すること
  - 環境に応じた分岐処理よりも、シンプルなデフォルト値を優先すること

## API設計とバージョニング

### 後方互換性

**基本方針: 後方互換性を保つのではなく、新方式に既存コードを修正する。**
- 変更時は影響範囲を特定し、すべての使用箇所を一括で更新する

**例外: 後方互換性を保つべきケース**
- 外部に公開されているAPI（将来的な可能性を含む）
- データベーススキーマの変更（マイグレーション戦略が必要）
- ユーザーデータに影響する変更

**破壊的変更の手順**
1. 変更の影響範囲をコードベース全体で検索
2. すべての使用箇所を特定
3. 変更を実装し、すべての使用箇所を一括更新
4. テストを実行して問題がないことを確認
5. 必要に応じてドキュメントを更新

## コーディングスタイル

### TypeScript 規約
- 型定義を行う場合は `interface` より `type` を優先する
- 関数定義ではアロー関数より `function` を優先する
- TypeScript ネイティブの `enum` の利用は避け Object Literal を使用する

### 環境変数へのアクセス
環境変数に直接アクセスせず、必ず valibot でパースした値を使用すること。
- `process.env.VARIABLE_NAME` を直接使用しない
- 環境変数を使用するモジュールごとに専用の設定ファイルを作成し、valibot でバリデーションを行う
- 例: `getConfig()` のような関数経由でアクセスする

### コメントの最小化
コードを読めば分かる自明な内容はコメントを書かないこと。
- ❌ 悪い例: `// バリデーション`、`// 顧客詳細ページへリダイレクト`
- ✅ 良い例: 複雑なビジネスロジックの「なぜ」を説明するコメント、アルゴリズムの意図を説明するコメント
- コメントが必要と感じる場合は、コードをより明確にリファクタリングできないか検討すること

### 中間変数・型の最小化
複数箇所から参照されない中間変数や型は使用せず、直接指定すること。
- 1箇所でしか使われない型エイリアスは作成せず、直接型を記述する
- 1箇所でしか使われない定数は、複数の場所で同じ値を使用する場合を除き、直接値を記述する
- 例外: 同じ文字列リテラルや数値を複数箇所で使用する場合は、定数として定義すること（DRY原則）

**型として使用する定数の扱い:**
定数を複数箇所で使用し、かつその型も必要な場合は、`const` で定義して `typeof` で型を参照すること。

❌ 悪い例: 型エイリアスと定数を別々に定義
```typescript
const ERROR_MESSAGE = "エラーが発生しました" as const;
export type ErrorMessage = typeof ERROR_MESSAGE;  // 不要な型定義
```

✅ 良い例: `const` だけを定義し、型は `typeof` で参照
```typescript
const ERROR_MESSAGE = "エラーが発生しました" as const;
// 型が必要な箇所では typeof ERROR_MESSAGE を直接使用
function handleError(): typeof ERROR_MESSAGE { return ERROR_MESSAGE; }
```

## 命名規則

名前は直感的でわかりやすく、同じ概念には一貫した命名を使用すること。

| 対象 | 形式 | 例 |
|------|------|-----|
| ファイル名 | kebab-case | `user-profile.tsx` |
| 関数名 | camelCase | `createUser` |
| 変数名 | camelCase | `fooBar` |
| コンポーネント名 | PascalCase | `LoginButton` |
| Object Literal | PascalCase | `const UserStatus = {...} as const` |

### ファイル名の一貫性
- **一貫性の原則**: 同じ概念やエンティティを指す場合は、ファイル名に関わらず常に同じ表現を使用すること
- **単数形・複数形の使い分け**: 複数を表す場合は複数形、単数を表す場合は単数形を適切に使い分けること

例: 顧客ノートに関連するファイル
- ✅ 良い例:
  - `customer-notes-container.tsx` - 複数のノートを扱う
  - `customer-notes-presenter.tsx` - 複数のノートを表示
  - `customer-notes-search-form.tsx` - 複数のノートを検索
  - `customer-note-card.tsx` - 単一のノートカード（単数形が適切）
- ❌ 悪い例:
  - `customer-notes-container.tsx`、`note-search-form.tsx`（`customer-notes` と `note` で表現が不統一）

この原則はファイル名だけでなく、変数名、関数名、型名などコード全体に適用すること。

## 外部ライブラリ

- ユースケースに絞った薄いラッパーの使用を検討すること
  - 過度に複雑になる場合や十分にシンプルな場合はラッパーを使用しない選択も可
  - ラッパーを作る目的は、外部ライブラリの API 変更や代替ライブラリへの移行時に、内部実装のみの変更で対応できるようにするため
  - 完全な API 互換性は不要で、プロジェクトで必要な機能のみを提供すればよい
