## 開発原則


- You Aren't Gonna Need It (YAGNI)
- Single Responsibility Principle
- Keep it Simple, Stupid (KISS)
- Avoid Hasty Abstractions (AHA)
- Don't repeat yourself (DRY)

## コーディングスタイル

- 型定義では type を優先する
- 関数定義では function を優先する
- TypeScript ネイティブの Enum の利用は避け Object Literal を使用する

## 命名規則

名前は直感的でわかりやすく、同じ概念には一貫した命名を使用すること。

- **ファイル名**: kebab（例: `user-profile.tsx`）
- **関数名**: camel（例: `createUser`）
- **変数名**: camel（例: `fooBar`）
- **コンポーネント名: pascal（例：LoginButton）
- **Object Literal**: pascal（例: `const UserStatus = { Active: 'active', Inactive: 'inactive' } as const`）

## ユーザー体験

ユーザーインターフェースは直感的で一貫性があり、予測可能でなければならない。

- デザインシステムに準拠し、統一された UI/UX パターンを使用すること
- すべての画面はレスポンシブデザインで、モバイル・タブレット・デスクトップに対応すること
- ローディング状態を明示し、ユーザーにフィードバックを提供すること
  - Skeleton を使用する際はロード後のデザインと一致させ CLS を防ぐこと
- エラーメッセージは統一されたフォーマットで、ユーザーフレンドリーであること
- アクセシビリティ標準（WCAG 2.1 レベル AA）を満たすこと
- ナビゲーションは直感的で、ユーザーが迷わない設計にすること
- **楽観的更新 (Optimistic Updates)**: 可能な場合はユーザーアクションに対して即座にフィードバックを提供すること
  - サーバーレスポンスを待たずに UI を更新し、体感速度を向上
  - 失敗時のロールバック処理を適切に実装すること
  - ユーザーに処理状態（pending, success, error）を明確に伝えること
- **マイクロインタラクション**: 細やかなアニメーションとフィードバックで UX を向上すること
  - ボタンクリック、ホバー、フォーカス時の視覚的フィードバック
  - 状態遷移時のスムーズなアニメーション（例: フェードイン、スライド）
  - ローディング、成功、エラーの視覚的な合図（例: スピナー、チェックマーク、エラーアイコン）
  - 過度なアニメーションは避け、パフォーマンスと accessibility を損なわないこと

## 外部ライブラリ

- ユースケースに絞った薄いラッパーの使用を検討すること
  - 過度に複雑になる場合や十分にシンプルな場合はラッパーを使用しない選択も可

## Nextjs

### Server Component First

- Server Component での実装を最優先とし、ユーザーのインタラクションが必要な場合にのみクライアントコンポーネントを採用すること
- データの取得は極力末端で行い、上位からバケツリレーで下位に渡すことを避けること

### Server Action

- データのミューテーションには Server Action を使用すること
- Server Action ではカバーできないことや、クライアントからのデータフェッチ用 API には Route Handler を使用すること
- Server Component で利用するデータ取得には使用しないこと
- Server Action はシンタックスシュガーであり、本質的には API と変わらず自由なパラメータで呼び出せるため、引き数がある場合は必ずバリデーションと適切な認証、認可を実施する

### Route Handler

- データフェッチなどのミューテーションを伴わないサーバー操作に使用すること
- cron 用の API など外部から利用されることを想定した API に使用すること

### Container / Presenter / Custom Hook

**Server Component:**

- データ取得やロジックは Container / Presenter パターンとして分離すること

```tsx
async function FooContainer({ id }: { id: string }) {
  const foo = await getFoo(id);
  return <FooPresenter foo={foo} />;
}
```

**Client Component:**

- データ取得やロジックを分離する場合は Custom Hook として分離すること

```tsx
function Foo({ id }: { id: string }) {
  const { foo } = useFoo(id);

  return <div>{foo.bar}</div>;
}
```

### Cache Component のキャッシュ戦略

#### cache directive

適切な use cache ディレクティブを利用すること。

Next.js は、それぞれ異なるユースケース向けに設計された 3 つのキャッシュディレクティブを提供する。

| 特徴                                 | `use cache`                      | `use cache: remote`                                              | `use cache: private`                         |
| ------------------------------------ | -------------------------------- | ---------------------------------------------------------------- | -------------------------------------------- |
| **動的なコンテキストで動作する**     | いいえ（静的コンテキストが必要） | はい（動的なコンテキスト向けに設計）                             | はい                                         |
| **`await cookies()` にアクセス**     | いいえ                           | いいえ                                                           | はい                                         |
| **`await headers()` にアクセス**     | いいえ                           | いいえ                                                           | はい                                         |
| **`await connection()` の後**        | いいえ（キャッシュしません）     | いいえ                                                           | いいえ                                       |
| **キャッシュハンドラーに保存**       | はい（サーバー側）               | はい（サーバー側）                                               | いいえ（クライアント側のみ）                 |
| **キャッシュスコープ**               | グローバル（共有）               | グローバル（共有）                                               | ユーザーごと（分離）                         |
| **ランタイムプリフェッチをサポート** | N/A (ビルド時に事前レンダリング) | いいえ                                                           | はい（設定されている場合）                   |
| **使用事例**                         | 静的共有コンテンツ（ビルド時）   | ランタイムコンテキストでの動的な共有コンテンツ（リクエストごと） | パーソナライズされたユーザー固有のコンテンツ |

##### "use cache" のユースケース

- コンテンツがビルド時に事前レンダリングできる場合
- コンテンツがすべてのユーザー間で共有される場合
- コンテンツがリクエスト固有のデータに依存しない場合

##### "use cache: remote" のユースケース

- 動的コンテキスト内でのキャッシュが必要な場合
- コンテンツがユーザー間で共有されるが、リクエストごとにレンダリングする必要がある場合（`await connection()` のあと）
- 高価な操作をサーバー側のキャッシュハンドラーにキャッシュしたい場合

##### "use cache: private" のユースケース

- コンテンツがユーザーごとにパーソナライズされる場合（Cookie、ヘッダーによって異なる）
- ユーザー固有のコンテンツの実行時プリフェッチが必要な場合
- コンテンツをユーザー間で共有してはならない場合

#### cacheLife

##### データの更新をアプリで制御できる場合

アプリ内の DB のデータや webhook で検知できる外部データが対象。

- カスタムプロファイル permanent を利用し、キャッシュの更新が必要なタイミングで `revalidateTag()` を行うこと
- `cacheTag()` を使って更新タイミングに応じたタグを設定すること
  - 例: `cacheTag("parent-delete", "foo-update")`

##### データの更新タイミングをアプリで制御できない場合

外部 API やデータの更新を制御できても一定間隔での更新で十分な場合が対象。

- `"hours"`、`"days"`、カスタム時間など要件に応じた時間を指定すること

### テスト基準

テストは品質保証の基盤であり、すべての新機能に対して必須である。

**テスト哲学:**

- **公開インターフェースのテスト**: 公開された API、関数、コンポーネントの動作をテストすること
- **内部実装のテストを避ける**: 内部のプライベートメソッドや実装詳細に依存したテストは避けること
  - 実装の変更に対してテストが壊れることを防ぐ
  - リファクタリングの自由度を保つ
  - テストは「何をするか」に焦点を当て、「どうやるか」には焦点を当てない

**統合テストの優先:**

- **結合された状態でのテスト**: 極力、実際の依存関係を使用した統合テストを優先すること
- **過剰な Mock の使用を避ける**: Mock は最小限にとどめ、必要な場合のみ使用すること
  - Mock を使うと実際の統合問題を見逃す可能性がある
  - Mock の保守コストが高くなる
  - テストが実装詳細に依存しやすくなる

**Mock 使用の原則:**

- **Mock が許容される場合**: 外部 API やサードパーティサービスなど、制御できない外部依存のみ
  - 例: 決済サービス、メール送信サービス、外部データプロバイダー
  - これらは信頼性、コスト、テスト実行速度の観点から Mock が適切
- **Mock を避けるべき場合**: プロジェクト内部の依存関係、データベース、ファイルシステム
  - これらは実際の実装を使用してテストすること

**データベーステスト:**

- **Mock データベースを避ける**: Mock や Fake のデータベース実装は使用しないこと
- **実際のデータベースを使用**: テストには以下のいずれかを使用すること
  - Docker コンテナで起動した実際のデータベース（PostgreSQL, MySQL など）
  - In-memory データベース（SQLite in-memory mode など）
  - トランザクションロールバックを使用したテスト分離
- これにより、SQL クエリ、制約、トリガーなどの実際の動作を検証できる

**テストカバレッジとタイプ:**

- 新機能・変更には必ずテストを作成すること
- テストカバレッジ目標は 80%以上を維持すること
- E2E テストで主要なユーザーフローを検証すること
- テストファースト開発を推奨し、Red-Green-Refactor サイクルを意識すること
- テストは読みやすく、保守しやすく、意図が明確であること
- エッジケース・エラーハンドリングもテストでカバーすること

### モニタリング・観測可能性

システムの状態を常に把握し、問題を早期に発見・対応できなければならない。

**ログとメトリクス:**

- ログは構造化された形式（JSON 等）で出力し、集約・検索可能にすること
- メトリクス（レスポンスタイム、エラー率、リソース使用率等）を継続的に収集すること
- ビジネスメトリクス（ユーザー行動、コンバージョン等）も追跡すること

**監視とアラート:**

- 重要な指標（エラー率、パフォーマンス低下等）に対してアラートを設定すること
- ダッシュボードでシステムの健全性を可視化すること
- 異常検知とアラート通知の仕組みを構築すること

**エラートラッキング:**

- クライアント・サーバー双方のエラーを追跡すること
- エラーの文脈情報（ユーザー ID、リクエスト内容等）を記録すること
- エラーの優先度付けとトリアージプロセスを確立すること

**パフォーマンス監視:**

- リアルユーザーモニタリング（RUM）でユーザー体験を計測すること
- API エンドポイントのレスポンスタイムを監視すること
- ボトルネックを特定し、継続的に改善すること

## タスク完了の条件

- lint エラーがないこと
- ソースコードが format されていること
- 型エラーがないこと
- ランタイムエラーがないこと

## マージ条件

- タスク完了の条件を満たしていること
- ユニットテスト、コンポーネントテスト、E2E テストがパスしていること
- デプロイが成功していること

## コマンド

### バリデーションチェック

lint, format, デッドコード検出、スペルチェックを行います
タスク完了時には必ず実施し、エラーが出ていないことを確認してください
エラーが出ているときはバリデーション自動修正の実施や、手動での改善を行ってください

`pnpm validate:check `

### バリデーション自動修正
lint, format, デッドコードの自動修正を行います。スペルチェックは手動で追加が必要です

`pnpm validate:fix`

## モノレポ

- 各モノレポパッケージでは JIT パッケージとして実装し、使用する側でビルド時にコンパイルすること

## MCP

- 外部ライブラリを使用する場合は必ず Context7 のツールを利用して、使用バージョンと一致した情報を取得すること
- GitHub の操作を行う際は Github のツールを優先すること
